#ifndef MAPPER_NSF_H_
#define MAPPER_NSF_H_

#include "Mapper.h"
//#include "MemoryMap.h"
#include "NsfFile.h"

//#include <algorithm>

class Mapper_NSF : public NesMapper {
public:
    std::array<Byte, 0x2000> Ram;
    std::array<Byte, 0x8000> Rom;

#define PLAYER_ADDR 0x4100
#define PLAYER_SIZE 0x0200
#define PLAYER_PAGE HI(PLAYER_ADDR)

#define RST_HANDLER 0x00
#define NMI_HANDLER 0x10
#define BRK_HANDLER 0x20
#define S_CALL_INIT   0x40
#define S_CALL_PLAY   0x50
#define OFFSET_S_CALL 0x05
#define SONG_COUNT 0x30

    std::array<Byte, PLAYER_SIZE> PlayerSoftware{
        0x4C, 0x60, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xA9, 0x01, 0x8D, 0xFD, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xBA, 0x8E, 0xFB, 0x01, 0x20, 0xFF, 0xFF, 0xAE, 0xFB, 0x01, 0x9A, 0x60, 0x00, 0x00, 0x00, 0x00,
        0xBA, 0x8E, 0xFB, 0x01, 0x20, 0xFF, 0xFF, 0xAE, 0xFB, 0x01, 0x9A, 0x60, 0x00, 0x00, 0x00, 0x00,
        0xA9, 0x00, 0x8D, 0x00, 0x20, 0x78, 0xA2, 0xFF, 0x9A, 0x48, 0x48, 0x48, 0x48, 0x48, 0x4C, 0xF0,
        0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xA9, 0x00, 0xA2, 0x60, 0xA8, 0x85, 0x00, 0x86, 0x01, 0x91, 0x00, 0xC8, 0xD0, 0xFB, 0xE8, 0xE0,
        0x80, 0xD0, 0xF4, 0xA2, 0x02, 0x86, 0x01, 0x91, 0x00, 0xC8, 0xD0, 0xFB, 0xE8, 0xE0, 0x08, 0xD0,
        0xF4, 0xA2, 0x00, 0x95, 0x00, 0xE8, 0xD0, 0xFB, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xA9, 0x00, 0xA2, 0x14, 0xCA, 0x9D, 0x00, 0x40, 0xD0, 0xFA, 0x8D, 0x15, 0x40, 0xA2, 0x0F, 0x8E,
        0x15, 0x40, 0xA2, 0x40, 0x8E, 0x17, 0x40, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xA0, 0x01, 0x8C, 0x16, 0x40, 0x88, 0x8C, 0x16, 0x40, 0xA9, 0x01, 0xA8, 0xAD, 0x16, 0x40, 0x6A,
        0x98, 0x2A, 0x90, 0xF7, 0x8D, 0xFC, 0x01, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xA9, 0x00, 0x8D, 0x00, 0x20, 0x20, 0x80, 0x41, 0x20, 0xB0, 0x41, 0xBA, 0x8E, 0xFB, 0x01, 0xAD,
        0xFF, 0x01, 0xAE, 0xFE, 0x01, 0x20, 0x40, 0x41, 0xAE, 0xFB, 0x01, 0x9A, 0x4C, 0x10, 0x42, 0x00,
        0xA9, 0x80, 0x8D, 0x00, 0x20, 0xAD, 0xFD, 0x01, 0xF0, 0xFB, 0xA9, 0x00, 0x8D, 0xFD, 0x01, 0x20,
        0x50, 0x41, 0x20, 0xD0, 0x41, 0xAD, 0xFC, 0x01, 0xF0, 0xEB, 0xAE, 0xFF, 0x01, 0xE8, 0xEC, 0x30,
        0x41, 0xD0, 0x02, 0xA2, 0x00, 0x8E, 0xFF, 0x01, 0x4C, 0xF0, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
    };
    
    explicit Mapper_NSF(const NsfFile & nsf) {
        Ram.fill(0);
        
        const auto n = nsf.NsfData.size();
        std::copy_n(nsf.NsfData.cbegin(), n, Rom.begin() + nsf.Header.LoadAddress - 0x8000);

        Rom[0x7FFA] = NMI_HANDLER;
        Rom[0x7FFB] = PLAYER_PAGE;
        Rom[0x7FFC] = RST_HANDLER;
        Rom[0x7FFD] = PLAYER_PAGE;
        Rom[0x7FFE] = BRK_HANDLER;
        Rom[0x7FFF] = PLAYER_PAGE;
        PlayerSoftware[S_CALL_INIT + OFFSET_S_CALL + 0] = LO(nsf.Header.InitAddress);
        PlayerSoftware[S_CALL_INIT + OFFSET_S_CALL + 1] = HI(nsf.Header.InitAddress);
        PlayerSoftware[S_CALL_PLAY + OFFSET_S_CALL + 0] = LO(nsf.Header.PlayAddress);
        PlayerSoftware[S_CALL_PLAY + OFFSET_S_CALL + 1] = HI(nsf.Header.PlayAddress);
        PlayerSoftware[SONG_COUNT] = nsf.Header.SongCount;
    }
    
    Word NametableAddress(const Word address) const override { return 0; }

    Byte GetCpuAt(const Word address) const override {
        const auto atype = GetCpuAddressType(address);
        switch (atype) {
        case CpuAddressType::RAM:
            return Ram[address & 0x1FFF];
        case CpuAddressType::ROM:
            return Rom[address & 0x7FFF];
        case CpuAddressType::PlayerSoftware:
            return PlayerSoftware[address - PLAYER_ADDR];
        }
        return 0;
    }

    void SetCpuAt(const Word address, const Byte value) override {
        const auto atype = GetCpuAddressType(address);
        if (atype == CpuAddressType::RAM) Ram[address & 0x1FFF] = value;
    }

    Byte GetPpuAt(const Word address) const override { return 0; }

    void SetPpuAt(const Word address, const Byte value) override {}

    enum class CpuAddressType {
        Unexpected,
        Invalid,
        PlayerSoftware,
        RAM,
        ROM,
    };

    CpuAddressType GetCpuAddressType(const Word address) const {
        if (address < 0x4020) return CpuAddressType::Unexpected;
        if (address < PLAYER_ADDR) return CpuAddressType::Invalid;
        if (address < (PLAYER_ADDR + PLAYER_SIZE)) return CpuAddressType::PlayerSoftware;
        if (address < 0x6000) return CpuAddressType::Invalid;
        if (address < 0x8000) return CpuAddressType::RAM;
        return CpuAddressType::ROM;
    }

};

#endif /* MAPPER_NSF_H_ */
